# ==========================================
# 1️⃣ 제너레이터(generator)가 필요한 이유
# ==========================================

# - 모든 값을 미리 메모리에 올리지 않고 필요할 때마다 하나씩 생성
# - 메모리 효율적 → 대규모 데이터 처리, 파일 처리, 무한 시퀀스 등
# - 반복문과 함께 쓰기 좋음 → for문 안에서 자연스럽게 사용 가능

# 예시 상황:
# - 로그 파일 10GB를 한 줄씩 처리
# - 무한 수열 생성 (0, 1, 2, 3, …)
# - 메모리가 제한된 환경에서 데이터 처리


# ==========================================
# 2️⃣ 메모리 효율 비교: 리스트 vs 제너레이터
# ==========================================

import sys

# 리스트: 모든 값을 미리 메모리에 저장
lst = [i for i in range(10000)]
print("리스트 크기:", sys.getsizeof(lst), "bytes")  # 큰 메모리 사용

# 제너레이터: 필요할 때 하나씩 생성
gen = (i for i in range(10000))
print("제너레이터 크기:", sys.getsizeof(gen), "bytes")  # 거의 0에 가까움

# 결과 해석:
# 리스트: 10,000개 값을 다 올려서 메모리 많이 사용
# 제너레이터: 값을 만들 수 있는 방법만 갖고 있음 → 메모리 거의 안 씀


# ==========================================
# 3️⃣ 제너레이터 문법과 특징
# ==========================================

# 리스트 컴프리헨션
lst = [i for i in range(5)]  # list: 모든 값 메모리에 저장

# 제너레이터 표현식
gen = (i for i in range(5))  # generator: 필요할 때 하나씩 생성

# 집합 컴프리헨션
st = {i for i in range(5)}   # set: 중복 제거, 순서 없음

# 딕셔너리 컴프리헨션
dct = {i: i*2 for i in range(5)}  # dict: key:value 딕셔너리

# ⚠️ (i for i in range(5))는 튜플 컴프리헨션이 아니라 항상 generator


# ==========================================
# 4️⃣ yield vs return
# ==========================================

# return → 값을 반환하고 함수 종료
# yield → 값을 반환하고 함수 상태 일시 정지, 다음 호출(next()) 시 이어서 실행

def g():
    yield 1
    yield 2
    yield 3

gen = g()
print(next(gen))  # 1
print(next(gen))  # 2
print(next(gen))  # 3

# 💡 시각적 비유:
# return → "우유 한 컵 주고 문 닫음"
# yield  → "우유 한 컵 주고 잠시 멈춤 → 다음 컵 필요하면 다시 열어서 줌"


# ==========================================
# 5️⃣ 무한 수열 예제
# ==========================================

def infinite_numbers():
    n = 0
    while True:
        yield n      # 현재 값 내보내고 일시 정지
        n += 1       # 다음 값 준비

gen = infinite_numbers()

# 처음 10개 값만 가져오기
for _ in range(10):
    print(next(gen))

# 출력:
# 0 1 2 3 4 5 6 7 8 9

# ✅ 무한 수열도 generator를 쓰면 안전하게 처리 가능
# 리스트로 만들면 메모리에 다 올려야 하므로 불가능
